---
// Playground App Component - Main interactive playground
---

<div x-data="playgroundApp" class="playground-container">
  <!-- Header -->
  <header class="playground-header">
    <div class="header-content">
      <!-- Left: Logo -->
      <div class="header-left">
        <button @click="activeView = 'endpoints'" class="logo">api.img.pro | playground</button>
      </div>

      <!-- Right: Actions -->
      <div class="header-right">
        <button x-show="activeView !== 'documentation'" @click="showCommandPalette = true" class="header-btn" title="Search endpoints (⌘K)">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
          </svg>
        </button>

        <button x-show="activeView !== 'documentation'" @click="showHistoryPanel = !showHistoryPanel" class="header-btn" title="History (⌘H)">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
            <path d="M3 3v5h5"></path>
            <path d="M12 7v5l4 2"></path>
          </svg>
        </button>

        <button x-show="activeView !== 'documentation'" @click="activeView = 'documentation'" class="header-btn" :class="{'active': activeView === 'documentation'}" title="Documentation">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
            <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
          </svg>
        </button>

        <button @click="showAuthModal = true" class="header-btn" :class="{'is-authenticated': isAuthenticated}" :title="isAuthenticated ? 'Authenticated' : 'Add API token'">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
            <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
          </svg>
        </button>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="playground-main">
    <!-- Endpoints View -->
    <div x-show="activeView === 'endpoints'" class="view-container">
      <div class="endpoints-grid">
        <!-- Sidebar -->
        <aside class="endpoints-sidebar">
          <template x-for="group in endpointGroups" :key="group.name">
            <div class="sidebar-section">
              <button @click="group.collapsed = !group.collapsed" class="sidebar-title-btn">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="chevron" :class="{'rotated': !group.collapsed}">
                  <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
                <h3 class="sidebar-title" x-text="group.name"></h3>
              </button>
              <div x-show="!group.collapsed" class="endpoint-list">
                <template x-for="endpointId in group.endpoints" :key="endpointId">
                  <div x-data="{ endpoint: getEndpoint(endpointId) }">
                    <button
                      @click="selectEndpoint(endpoint)"
                      :class="{'active': selectedEndpoint?.id === endpoint.id}"
                      class="endpoint-item"
                    >
                      <span class="method-badge" :class="'method-' + endpoint.method.toLowerCase()" x-text="endpoint.method"></span>
                      <span class="endpoint-path" x-text="endpoint.path"></span>
                    </button>
                  </div>
                </template>
              </div>
            </div>
          </template>
        </aside>

        <!-- Main Content - Split Layout -->
        <div class="endpoint-content-split">
          <template x-if="selectedEndpoint">
            <div class="split-container" :style="`grid-template-columns: ${splitPosition}% 6px ${100 - splitPosition}%`">
              <!-- Left: Request Builder -->
              <div class="split-left">
                <div class="request-detail">
                  <!-- Compact Header -->
                  <div class="request-header">
                    <div class="request-title">
                      <span class="method-badge" :class="'method-' + selectedEndpoint.method.toLowerCase()" x-text="selectedEndpoint.method"></span>
                      <span class="request-path" x-text="selectedEndpoint.path"></span>
                    </div>
                    <button
                      @click="executeRequest"
                      :disabled="isLoading"
                      class="btn-run-compact"
                      title="Run Request (⌘↵)"
                    >
                      <svg x-show="!isLoading" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                      </svg>
                      <span x-show="isLoading" class="spinner-sm"></span>
                      <span>Run</span>
                    </button>
                  </div>
                  <p class="request-description" x-text="selectedEndpoint.description"></p>

                  <!-- Minimal Tabs -->
                  <div class="request-tabs">
                    <button @click="requestTab = 'request'" :class="{'active': requestTab === 'request'}" class="tab-minimal">Request</button>
                    <button @click="requestTab = 'curl'" :class="{'active': requestTab === 'curl'}" class="tab-minimal">cURL</button>
                    <button @click="requestTab = 'javascript'" :class="{'active': requestTab === 'javascript'}" class="tab-minimal">JavaScript</button>
                    <button @click="requestTab = 'python'" :class="{'active': requestTab === 'python'}" class="tab-minimal">Python</button>
                    <button @click="requestTab = 'php'" :class="{'active': requestTab === 'php'}" class="tab-minimal">PHP</button>
                  </div>

                  <!-- Request Content -->
                  <div class="request-content">

                <!-- Request Tab -->
                <div x-show="requestTab === 'request'">
                  <div class="param-form">
                    <!-- Base URL Section -->
                    <div class="param-section-compact">
                      <div class="param-section-header">
                        <h4>Base URL</h4>
                        <button @click="toggleEndpointMode" class="btn-toggle" type="button">
                          <span x-text="endpointMode === 'production' ? 'Custom' : 'Production'"></span>
                        </button>
                      </div>

                      <!-- Production Mode (Read-only) -->
                      <div x-show="endpointMode === 'production'" class="endpoint-display">
                        <span class="endpoint-url">https://api.img.pro</span>
                      </div>

                      <!-- Custom Mode (Editable) -->
                      <input
                        x-show="endpointMode === 'custom'"
                        type="text"
                        x-model="customApiUrl"
                        @input="saveCustomApiUrl"
                        class="input"
                        placeholder="https://test.api.img.pro"
                      >
                    </div>

                    <!-- Auth Section -->
                    <div x-show="selectedEndpoint.requiresAuth || selectedEndpoint.optionalAuth" class="param-section-compact">
                      <div class="param-section-header">
                        <h4>
                          <span>Authentication</span>
                          <span x-show="selectedEndpoint.requiresAuth" class="required">*</span>
                        </h4>
                      </div>
                      <div class="input-with-icon">
                        <input
                          :type="showToken ? 'text' : 'password'"
                          x-model="token"
                          @input="saveToken"
                          class="input"
                          placeholder="Bearer token"
                          :required="selectedEndpoint.requiresAuth"
                        >
                        <button @click="showToken = !showToken" type="button" class="input-icon-btn" :title="showToken ? 'Hide token' : 'Show token'">
                          <svg x-show="!showToken" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                          </svg>
                          <svg x-show="showToken" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                            <line x1="1" y1="1" x2="23" y2="23"></line>
                          </svg>
                        </button>
                      </div>
                    </div>

                    <!-- Path Parameters -->
                    <template x-if="selectedEndpoint.parameters.filter(p => p.location === 'path').length > 0">
                      <div class="param-section">
                        <div class="param-section-header">
                          <h4>Path Parameters</h4>
                        </div>
                        <template x-for="param in selectedEndpoint.parameters.filter(p => p.location === 'path')" :key="param.name">
                          <div class="param-field">
                            <label class="param-field-label">
                              <span x-text="param.name"></span>
                              <span x-show="param.required" class="required">*</span>
                            </label>
                            <input
                              :type="param.type === 'number' ? 'number' : 'text'"
                              x-model="requestParams[param.name]"
                              class="input"
                              :placeholder="param.placeholder"
                              :required="param.required"
                            >
                            <p class="param-hint" x-text="param.description"></p>
                          </div>
                        </template>
                      </div>
                    </template>

                    <!-- Query Parameters -->
                    <template x-if="selectedEndpoint.parameters.filter(p => p.location === 'query').length > 0">
                      <div class="param-section">
                        <div class="param-section-header">
                          <h4>Query Parameters</h4>
                          <template x-if="selectedEndpoint.parameters.filter(p => p.location === 'query' && !p.required).length > 0">
                            <button @click="showOptionalParams.query = !showOptionalParams.query" class="btn-toggle" type="button">
                              <span x-text="showOptionalParams.query ? 'Hide' : 'Show'"></span>
                              <span x-text="selectedEndpoint.parameters.filter(p => p.location === 'query' && !p.required).length"></span>
                              <span>optional</span>
                            </button>
                          </template>
                        </div>
                        <!-- Required query params -->
                        <template x-for="param in selectedEndpoint.parameters.filter(p => p.location === 'query' && p.required)" :key="param.name">
                          <div class="param-field">
                            <label class="param-field-label">
                              <span x-text="param.name"></span>
                              <span class="required">*</span>
                            </label>
                            <input
                              :type="param.type === 'number' ? 'number' : 'text'"
                              x-model="requestParams[param.name]"
                              class="input"
                              :placeholder="param.placeholder"
                              required
                            >
                            <p class="param-hint" x-text="param.description"></p>
                          </div>
                        </template>
                        <!-- Optional query params (collapsible) -->
                        <div x-show="showOptionalParams.query">
                          <template x-for="param in selectedEndpoint.parameters.filter(p => p.location === 'query' && !p.required)" :key="param.name">
                            <div class="param-field">
                              <label class="param-field-label">
                                <span x-text="param.name"></span>
                              </label>
                              <input
                                :type="param.type === 'number' ? 'number' : 'text'"
                                x-model="requestParams[param.name]"
                                class="input"
                                :placeholder="param.placeholder"
                              >
                              <p class="param-hint" x-text="param.description"></p>
                            </div>
                          </template>
                        </div>
                      </div>
                    </template>

                    <!-- Body Parameters -->
                    <template x-if="selectedEndpoint.parameters.filter(p => p.location === 'body').length > 0">
                      <div class="param-section">
                        <div class="param-section-header">
                          <h4>Body Parameters</h4>
                          <template x-if="selectedEndpoint.parameters.filter(p => p.location === 'body' && !p.required).length > 0">
                            <button @click="showOptionalParams.body = !showOptionalParams.body" class="btn-toggle" type="button">
                              <span x-text="showOptionalParams.body ? 'Hide' : 'Show'"></span>
                              <span x-text="selectedEndpoint.parameters.filter(p => p.location === 'body' && !p.required).length"></span>
                              <span>optional</span>
                            </button>
                          </template>
                        </div>
                        <!-- Required body params -->
                        <template x-for="param in selectedEndpoint.parameters.filter(p => p.location === 'body' && p.required)" :key="param.name">
                          <div class="param-field">
                            <label class="param-field-label">
                              <span x-text="param.name"></span>
                              <span class="required">*</span>
                            </label>
                            <!-- File input -->
                            <template x-if="param.type === 'file'">
                              <div class="file-input-wrapper">
                                <input
                                  type="file"
                                  @change="handleFileSelect($event, param.name)"
                                  class="file-input"
                                  required
                                  accept="image/*"
                                >
                                <div class="file-input-display">
                                  <span x-text="requestParams[param.name]?.name || 'Choose a file...'" class="file-name"></span>
                                  <button type="button" class="btn btn-secondary btn-sm">Browse</button>
                                </div>
                              </div>
                            </template>
                            <!-- Regular input -->
                            <template x-if="param.type !== 'file'">
                              <input
                                :type="param.type === 'number' ? 'number' : 'text'"
                                x-model="requestParams[param.name]"
                                class="input"
                                :placeholder="param.placeholder"
                                required
                              >
                            </template>
                            <p class="param-hint" x-text="param.description"></p>
                          </div>
                        </template>
                        <!-- Optional body params (collapsible) -->
                        <div x-show="showOptionalParams.body">
                          <template x-for="param in selectedEndpoint.parameters.filter(p => p.location === 'body' && !p.required)" :key="param.name">
                            <div class="param-field">
                              <label class="param-field-label">
                                <span x-text="param.name"></span>
                              </label>
                              <input
                                :type="param.type === 'number' ? 'number' : 'text'"
                                x-model="requestParams[param.name]"
                                class="input"
                                :placeholder="param.placeholder"
                              >
                              <p class="param-hint" x-text="param.description"></p>
                            </div>
                          </template>
                        </div>
                      </div>
                    </template>
                  </div>
                </div>

                <!-- cURL Tab -->
                <div x-show="requestTab === 'curl'">
                  <div class="code-example">
                    <button @click="copyCode(generateCurl(), 'curl')" class="copy-btn" :class="{'copied': copiedCode === 'curl'}">
                      <svg x-show="copiedCode !== 'curl'" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                      </svg>
                      <svg x-show="copiedCode === 'curl'" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20 6 9 17 4 12"></polyline>
                      </svg>
                      <span x-text="copiedCode === 'curl' ? 'Copied!' : 'Copy'"></span>
                    </button>
                    <pre><code class="language-bash" x-text="generateCurl()"></code></pre>
                  </div>
                </div>

                <!-- JavaScript Tab -->
                <div x-show="requestTab === 'javascript'">
                  <div class="code-example">
                    <button @click="copyCode(generateJavaScript(), 'javascript')" class="copy-btn" :class="{'copied': copiedCode === 'javascript'}">
                      <svg x-show="copiedCode !== 'javascript'" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                      </svg>
                      <svg x-show="copiedCode === 'javascript'" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20 6 9 17 4 12"></polyline>
                      </svg>
                      <span x-text="copiedCode === 'javascript' ? 'Copied!' : 'Copy'"></span>
                    </button>
                    <pre><code class="language-javascript" x-text="generateJavaScript()"></code></pre>
                  </div>
                </div>

                <!-- Python Tab -->
                <div x-show="requestTab === 'python'">
                  <div class="code-example">
                    <button @click="copyCode(generatePython(), 'python')" class="copy-btn" :class="{'copied': copiedCode === 'python'}">
                      <svg x-show="copiedCode !== 'python'" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                      </svg>
                      <svg x-show="copiedCode === 'python'" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20 6 9 17 4 12"></polyline>
                      </svg>
                      <span x-text="copiedCode === 'python' ? 'Copied!' : 'Copy'"></span>
                    </button>
                    <pre><code class="language-python" x-text="generatePython()"></code></pre>
                  </div>
                </div>

                <!-- PHP Tab -->
                <div x-show="requestTab === 'php'">
                  <div class="code-example">
                    <button @click="copyCode(generatePHP(), 'php')" class="copy-btn" :class="{'copied': copiedCode === 'php'}">
                      <svg x-show="copiedCode !== 'php'" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                      </svg>
                      <svg x-show="copiedCode === 'php'" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20 6 9 17 4 12"></polyline>
                      </svg>
                      <span x-text="copiedCode === 'php' ? 'Copied!' : 'Copy'"></span>
                    </button>
                    <pre><code class="language-php" x-text="generatePHP()"></code></pre>
                  </div>
                </div>
                  </div>
                </div>
              </div>

              <!-- Drag Handle -->
              <div
                class="split-drag-handle"
                @mousedown="startDragging"
                @touchstart="startDragging"
                title="Drag to resize"
              >
                <div class="drag-handle-line"></div>
              </div>

              <!-- Right: Response Panel (Always Visible) -->
              <div class="split-right">
                <div x-show="response" class="response-detail">
                  <!-- Compact Response Header -->
                  <div class="response-header-compact">
                    <div class="response-title">
                      <span class="status-badge" :class="'status-' + getStatusClass(response?.status)">
                        <span x-text="response?.status"></span>
                      </span>
                      <span class="status-text" x-text="response?.statusText"></span>
                    </div>
                    <span class="response-time-badge" x-text="(response?.time || 0) + 'ms'"></span>
                  </div>

                  <!-- Response Content -->
                  <div class="response-content">
                    <!-- Request Details (collapsible) -->
                    <details x-show="response?.request" class="debug-section">
                      <summary>Request Details</summary>
                      <div class="debug-content">
                        <div class="debug-row">
                          <span class="debug-label">URL</span>
                          <code class="debug-value" x-text="response?.request?.url"></code>
                        </div>
                        <div class="debug-row">
                          <span class="debug-label">Method</span>
                          <code class="debug-value" x-text="response?.request?.method"></code>
                        </div>
                        <div class="debug-row">
                          <span class="debug-label">Headers</span>
                          <pre class="debug-code"><code x-text="JSON.stringify(response?.request?.headers || {}, null, 2)"></code></pre>
                        </div>
                        <div class="debug-row" x-show="response?.request?.bodyType && response?.request?.bodyType !== 'undefined'">
                          <span class="debug-label">Body Type</span>
                          <code class="debug-value" x-text="response?.request?.bodyType || 'none'"></code>
                        </div>
                      </div>
                    </details>

                    <!-- Response Body -->
                    <div class="response-body-section">
                      <div class="response-body-header">
                        <h4>Response</h4>
                      </div>
                      <div class="response-code">
                        <pre><code x-text="formatResponseBody(response?.body)"></code></pre>
                      </div>
                    </div>
                  </div>
                </div>

                <!-- Empty State -->
                <div x-show="!response" class="response-empty-state">
                  <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"></path>
                  </svg>
                  <h3>No request sent yet</h3>
                  <p>Fill in any required parameters and click <strong>Run</strong> to send your request</p>
                </div>
              </div>
            </div>
          </template>

          <!-- Empty State -->
          <template x-if="!selectedEndpoint">
            <div class="empty-state">
              <h3>Select an endpoint to get started</h3>
              <p>Choose an endpoint from the sidebar to start testing</p>
            </div>
          </template>
        </div>
      </div>
    </div>

    <!-- Documentation View -->
    <div x-show="activeView === 'documentation'" class="view-container">
      <div class="documentation" x-data="documentationViewer">
        <div x-show="loading" class="loading-state">
          <div class="spinner"></div>
          <p>Loading documentation...</p>
        </div>
        <div x-show="!loading && error" class="error-state">
          <p x-text="error"></p>
        </div>
        <div x-show="!loading && !error" class="documentation-content" x-html="renderedDocs"></div>
      </div>
    </div>

    <!-- History Slide-out Panel -->
    <div x-show="showHistoryPanel" x-cloak class="history-panel" @click.self="showHistoryPanel = false">
      <div class="panel-content">
        <div class="panel-header">
          <h2>History</h2>
          <div class="panel-header-actions">
            <button @click="clearHistory" class="btn btn-ghost btn-sm">Clear All</button>
            <button @click="showHistoryPanel = false" class="btn btn-ghost btn-icon">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>
        </div>
        <div class="panel-body">
          <div class="history-list">
            <template x-for="item in requestHistory" :key="item.id">
              <button class="history-item" @click="loadFromHistory(item); showHistoryPanel = false">
                <div class="history-method">
                  <span class="method-badge" :class="'method-' + item.method.toLowerCase()" x-text="item.method"></span>
                </div>
                <div class="history-details">
                  <p class="history-path" x-text="item.path"></p>
                  <p class="history-timestamp" x-text="formatTimestamp(item.timestamp)"></p>
                </div>
                <div class="history-status">
                  <span :class="'status-' + getStatusClass(item.status)" x-text="item.status"></span>
                </div>
              </button>
            </template>
            <div x-show="requestHistory.length === 0" class="empty-history">
              <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                <path d="M3 3v5h5"></path>
                <path d="M12 7v5l4 2"></path>
              </svg>
              <p>No requests yet</p>
              <p class="text-muted">Send a request to see it appear here</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Command Palette -->
    <div x-show="showCommandPalette" x-cloak class="command-palette-overlay" @click.self="showCommandPalette = false" @keydown.escape.window="showCommandPalette = false">
      <div class="command-palette">
        <div class="command-search">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
          </svg>
          <input
            type="text"
            x-model="commandSearch"
            placeholder="Search endpoints..."
            class="command-input"
            x-ref="commandInput"
            @keydown.down.prevent="selectedCommandIndex = Math.min(selectedCommandIndex + 1, filteredEndpoints.length - 1)"
            @keydown.up.prevent="selectedCommandIndex = Math.max(selectedCommandIndex - 1, 0)"
            @keydown.enter.prevent="selectCommandEndpoint(filteredEndpoints[selectedCommandIndex])"
          >
          <span class="kbd">ESC</span>
        </div>
        <div class="command-results">
          <template x-for="(endpoint, index) in filteredEndpoints" :key="endpoint.id">
            <button
              @click="selectCommandEndpoint(endpoint)"
              :class="{'active': index === selectedCommandIndex}"
              class="command-item"
            >
              <span class="method-badge" :class="'method-' + endpoint.method.toLowerCase()" x-text="endpoint.method"></span>
              <span class="command-path" x-text="endpoint.path"></span>
              <span class="command-description" x-text="endpoint.description"></span>
            </button>
          </template>
          <div x-show="filteredEndpoints.length === 0" class="command-empty">
            <p>No endpoints found</p>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Theme Toggle (Bottom Left - Desktop Only) -->
  <button @click="toggleTheme" class="theme-toggle" title="Toggle theme (⌘⇧L)">
    <svg x-show="currentTheme === 'dark'" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
    <svg x-show="currentTheme === 'light'" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
  </button>

  <!-- Auth Modal -->
  <div x-show="showAuthModal" x-cloak class="modal" @click.self="showAuthModal = false">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Authentication</h2>
        <button @click="showAuthModal = false" class="btn btn-ghost btn-icon">✕</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label class="label">API Token</label>
          <input
            type="password"
            x-model="token"
            class="input"
            placeholder="Enter your API token"
            @keyup.enter="saveToken"
          >
          <p class="help-text">Stored in your browser only - never sent to our servers</p>
        </div>
      </div>
      <div class="modal-footer">
        <button @click="showAuthModal = false" class="btn btn-secondary">Cancel</button>
        <button @click="saveToken" class="btn btn-primary">Save Token</button>
      </div>
    </div>
  </div>

</div>

<script>
  // Playground App Alpine Component
  document.addEventListener('alpine:init', () => {
    Alpine.data('playgroundApp', () => ({
      // State
      activeView: localStorage.getItem('img_api_token') ? 'endpoints' : 'documentation',
      selectedEndpoint: null,
      requestTab: 'request',
      endpointMode: localStorage.getItem('endpoint_mode') || 'production',
      customApiUrl: localStorage.getItem('custom_api_url') || 'https://test.api.img.pro',
      token: localStorage.getItem('img_api_token') || '',
      isAuthenticated: false,
      isLoading: false,
      response: null,
      showToken: false,
      lastRequest: null,
      currentTheme: document.documentElement.getAttribute('data-theme') || 'light',
      showOptionalParams: {
        query: false,
        body: false
      },
      splitView: false,
      codeLanguage: 'curl',

      // Split Pane Dragging
      splitPosition: parseInt(localStorage.getItem('split_position') || '45'),
      isDragging: false,

      // Modals & Panels
      showAuthModal: false,
      showCommandPalette: false,
      showHistoryPanel: false,

      // Command Palette
      commandSearch: '',
      selectedCommandIndex: 0,

      // Request Data
      requestParams: {},

      // History
      requestHistory: JSON.parse(localStorage.getItem('request_history') || '[]'),

      // Clipboard
      copiedCode: null,

      // Endpoint Groups (CRUD - sorted by /media then /media/{id})
      endpointGroups: [
        {
          name: 'Create',
          collapsed: false,
          endpoints: ['upload', 'import']  // POST /v1/upload, /v1/import
        },
        {
          name: 'Read',
          collapsed: false,
          endpoints: ['list-media', 'get-media']  // GET /v1/media, /v1/media/{id}
        },
        {
          name: 'Update',
          collapsed: false,
          endpoints: ['batch-update', 'update-media']  // PATCH /v1/media, /v1/media/{id}
        },
        {
          name: 'Delete',
          collapsed: false,
          endpoints: ['batch-delete', 'delete-media']  // DELETE /v1/media, /v1/media/{id}
        }
      ],

      // Endpoints
      endpoints: [
        {
          id: 'upload',
          method: 'POST',
          path: '/v1/upload',
          description: 'Upload an image file',
          requiresAuth: true,
          parameters: [
            {
              name: 'file',
              type: 'file',
              location: 'body',
              required: true,
              placeholder: '',
              description: 'Image file (JPG, PNG, GIF, WebP, SVG, HEIC, AVIF - max 70MB)'
            },
            {
              name: 'description',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: 'Summer vacation photo',
              description: 'Optional caption or note about this image'
            },
            {
              name: 'tags',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: 'vacation,beach,sunset',
              description: 'Search keywords (max 10, auto-lowercased, duplicates removed)'
            },
            {
              name: 'ttl',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: '7d',
              description: 'Auto-delete after this period (5m to 90d, e.g., 2h, 7d, 30d)'
            },
            {
              name: 'public',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: '1',
              description: 'Access control: 1 = anyone can view, 0 = team only'
            }
          ]
        },
        {
          id: 'import',
          method: 'POST',
          path: '/v1/import',
          description: 'Import an image from a URL',
          requiresAuth: true,
          parameters: [
            {
              name: 'url',
              type: 'text',
              location: 'body',
              required: true,
              placeholder: 'https://example.com/photo.jpg',
              description: 'Public image URL to fetch (30 second timeout)'
            },
            {
              name: 'description',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: 'Imported from website',
              description: 'Optional caption or note about this image'
            },
            {
              name: 'tags',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: 'imported,website',
              description: 'Search keywords (max 10, auto-lowercased, duplicates removed)'
            },
            {
              name: 'ttl',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: '30d',
              description: 'Auto-delete after this period (5m to 90d, e.g., 2h, 7d, 30d)'
            },
            {
              name: 'public',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: '1',
              description: 'Access control: 1 = anyone can view, 0 = team only'
            }
          ]
        },
        {
          id: 'list-media',
          method: 'GET',
          path: '/v1/media',
          description: 'List media items with pagination and filtering',
          requiresAuth: true,
          parameters: [
            {
              name: 'limit',
              type: 'number',
              location: 'query',
              required: false,
              placeholder: '50',
              description: 'Items per page (1-100, defaults to 50)'
            },
            {
              name: 'cursor',
              type: 'text',
              location: 'query',
              required: false,
              placeholder: '1704067200_123',
              description: 'Next page token from previous response (recommended)'
            },
            {
              name: 'offset',
              type: 'number',
              location: 'query',
              required: false,
              placeholder: '0',
              description: 'Skip first N items (deprecated - use cursor instead)'
            },
            {
              name: 'ids',
              type: 'text',
              location: 'query',
              required: false,
              placeholder: 'abc123,def456',
              description: 'Fetch only these specific items (comma-separated)'
            },
            {
              name: 'tags',
              type: 'text',
              location: 'query',
              required: false,
              placeholder: 'vacation,beach',
              description: 'Filter by tags (combine with tag_mode)'
            },
            {
              name: 'tag_mode',
              type: 'text',
              location: 'query',
              required: false,
              placeholder: 'any',
              description: 'Match any tag (OR) or all tags (AND)'
            }
          ]
        },
        {
          id: 'get-media',
          method: 'GET',
          path: '/v1/media/{id}',
          description: 'Get a specific media item',
          requiresAuth: false,
          optionalAuth: true,
          parameters: [
            {
              name: 'id',
              type: 'text',
              location: 'path',
              required: true,
              placeholder: 'abc123',
              description: 'Media ID (works without auth if media is public)'
            }
          ]
        },
        {
          id: 'update-media',
          method: 'PATCH',
          path: '/v1/media/{id}',
          description: 'Update a single media item',
          requiresAuth: true,
          parameters: [
            {
              name: 'id',
              type: 'text',
              location: 'path',
              required: true,
              placeholder: 'abc123',
              description: 'Media ID to update'
            },
            {
              name: 'description',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: 'Updated caption',
              description: 'New description (empty string clears it)'
            },
            {
              name: 'tags',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: 'nature,landscape',
              description: 'Tags to add/remove/replace (depends on tag_mode)'
            },
            {
              name: 'tag_mode',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: 'replace',
              description: 'How to apply tags: replace (default), add, or remove'
            },
            {
              name: 'public',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: 'true',
              description: 'Change access: true = anyone, false = team only'
            }
          ]
        },
        {
          id: 'delete-media',
          method: 'DELETE',
          path: '/v1/media/{id}',
          description: 'Delete a media item',
          requiresAuth: true,
          parameters: [
            {
              name: 'id',
              type: 'text',
              location: 'path',
              required: true,
              placeholder: 'abc123',
              description: 'Media ID to permanently delete'
            }
          ]
        },
        {
          id: 'batch-update',
          method: 'PATCH',
          path: '/v1/media',
          description: 'Update multiple media items in one request (max 100)',
          requiresAuth: true,
          parameters: [
            {
              name: 'ids',
              type: 'text',
              location: 'query',
              required: true,
              placeholder: 'abc123,def456,ghi789',
              description: 'Media IDs to update (max 100, comma-separated)'
            },
            {
              name: 'description',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: 'Batch updated caption',
              description: 'Apply this description to all items'
            },
            {
              name: 'tags',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: 'archived,batch',
              description: 'Tags to apply based on tag_mode'
            },
            {
              name: 'tag_mode',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: 'add',
              description: 'How to apply tags: replace, add, or remove'
            },
            {
              name: 'public',
              type: 'text',
              location: 'body',
              required: false,
              placeholder: 'false',
              description: 'Change access for all: true = anyone, false = team only'
            }
          ]
        },
        {
          id: 'batch-delete',
          method: 'DELETE',
          path: '/v1/media',
          description: 'Delete multiple media items in one request',
          requiresAuth: true,
          parameters: [
            {
              name: 'ids',
              type: 'text',
              location: 'query',
              required: true,
              placeholder: 'abc123,def456,ghi789',
              description: 'Media IDs to permanently delete (max 100, comma-separated)'
            }
          ]
        }
      ],

      // Initialize
      init() {
        this.loadAuth();
        this.selectEndpoint(this.endpoints[0]);

        // Watch for theme changes
        const themeObserver = new MutationObserver(() => {
          this.currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ['data-theme']
        });

        // Watch for tab changes to trigger syntax highlighting
        this.$watch('requestTab', () => {
          this.$nextTick(() => {
            document.querySelectorAll('.code-example pre code').forEach((block) => {
              if (window.Prism) {
                window.Prism.highlightElement(block);
              }
            });
          });
        });

        // Watch for command palette to focus input
        this.$watch('showCommandPalette', (value) => {
          if (value) {
            this.commandSearch = '';
            this.selectedCommandIndex = 0;
            this.$nextTick(() => this.$refs.commandInput?.focus());
          }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          // Cmd/Ctrl + K - Command Palette
          if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
            e.preventDefault();
            this.showCommandPalette = !this.showCommandPalette;
          }
          // Cmd/Ctrl + H - History
          if ((e.metaKey || e.ctrlKey) && e.key === 'h') {
            e.preventDefault();
            this.showHistoryPanel = !this.showHistoryPanel;
          }
          // Cmd/Ctrl + Enter - Run request
          if ((e.metaKey || e.ctrlKey) && e.key === 'Enter' && this.selectedEndpoint) {
            e.preventDefault();
            this.executeRequest();
          }
        });
      },

      // Computed properties
      get filteredEndpoints() {
        // Create endpoint order map based on CRUD groups
        const endpointOrder = {};
        this.endpointGroups.forEach((group, groupIndex) => {
          group.endpoints.forEach((endpointId, endpointIndex) => {
            endpointOrder[endpointId] = groupIndex * 100 + endpointIndex;
          });
        });

        let results = this.endpoints;

        // Filter if search query exists
        if (this.commandSearch) {
          const search = this.commandSearch.toLowerCase();
          results = results.filter(ep =>
            ep.path.toLowerCase().includes(search) ||
            ep.description.toLowerCase().includes(search) ||
            ep.method.toLowerCase().includes(search)
          );
        }

        // Sort by CRUD group order (same as navigation)
        return results.sort((a, b) => {
          const orderA = endpointOrder[a.id] ?? 999;
          const orderB = endpointOrder[b.id] ?? 999;
          return orderA - orderB;
        });
      },

      // Command Palette
      selectCommandEndpoint(endpoint) {
        if (endpoint) {
          this.selectEndpoint(endpoint);
          this.showCommandPalette = false;
          this.activeView = 'endpoints';
        }
      },

      // Auth Management
      loadAuth() {
        const token = localStorage.getItem('img_api_token');
        if (token) {
          this.token = token;
          this.isAuthenticated = true;
        }
      },

      saveToken() {
        if (this.token) {
          localStorage.setItem('img_api_token', this.token);
          this.isAuthenticated = true;
        } else {
          localStorage.removeItem('img_api_token');
          this.isAuthenticated = false;
        }
        this.showAuthModal = false;

        // If in documentation view and token was saved, go to playground
        if (this.activeView === 'documentation' && this.token) {
          this.activeView = 'endpoints';
        }

        // If in playground and token was removed, go to documentation
        if (this.activeView === 'endpoints' && !this.token) {
          this.activeView = 'documentation';
        }
      },

      // Theme Management
      toggleTheme() {
        this.$store.theme.toggle();
      },

      // Split Pane Resizing
      startDragging(e) {
        this.isDragging = true;
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';

        // Get the container element once
        const container = document.querySelector('.split-container');
        if (!container) {
          console.error('Split container not found');
          return;
        }

        const handleDrag = (dragEvent) => {
          if (!this.isDragging) return;

          const rect = container.getBoundingClientRect();
          const clientX = dragEvent.type.includes('touch')
            ? dragEvent.touches[0].clientX
            : dragEvent.clientX;

          const newPosition = ((clientX - rect.left) / rect.width) * 100;

          // Constrain between 20% and 80%
          this.splitPosition = Math.max(20, Math.min(80, newPosition));
        };

        const stopDragging = () => {
          if (this.isDragging) {
            this.isDragging = false;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            localStorage.setItem('split_position', this.splitPosition.toString());
          }
          document.removeEventListener('mousemove', handleDrag);
          document.removeEventListener('mouseup', stopDragging);
          document.removeEventListener('touchmove', handleDrag);
          document.removeEventListener('touchend', stopDragging);
        };

        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('mouseup', stopDragging);
        document.addEventListener('touchmove', handleDrag);
        document.addEventListener('touchend', stopDragging);

        e.preventDefault();
      },

      // Endpoint Mode
      toggleEndpointMode() {
        this.endpointMode = this.endpointMode === 'production' ? 'custom' : 'production';
        localStorage.setItem('endpoint_mode', this.endpointMode);
      },

      saveCustomApiUrl() {
        const url = this.customApiUrl.trim();
        localStorage.setItem('custom_api_url', url);
      },

      getApiUrl() {
        if (this.endpointMode === 'production') {
          return 'https://api.img.pro';
        } else {
          // Remove trailing slash if present
          return (this.customApiUrl || 'https://test.api.img.pro').replace(/\/$/, '');
        }
      },

      // Endpoint Selection
      selectEndpoint(endpoint) {
        this.selectedEndpoint = endpoint;
        this.requestParams = {};
        this.response = null;
        this.requestTab = 'request';
      },

      // Get endpoint by ID
      getEndpoint(id) {
        return this.endpoints.find(e => e.id === id);
      },


      // File Handling
      handleFileSelect(event, paramName) {
        const file = event.target.files[0];
        if (file) {
          this.requestParams[paramName] = file;
        }
      },

      // Request Execution
      async executeRequest() {
        this.isLoading = true;
        this.response = null;

        try {
          const url = this.buildUrl();
          const options = this.buildRequestOptions();

          // Debug logging
          console.log('[Playground] Request URL:', url);
          console.log('[Playground] Request method:', options.method);
          console.log('[Playground] Request headers:', options.headers);
          console.log('[Playground] Has body:', !!options.body);
          if (this.token) {
            console.log('[Playground] Token length:', this.token.length);
            console.log('[Playground] Token format:', this.token.includes('|') ? 'ID|token' : 'plain');
          }

          // Store request details for debugging
          this.lastRequest = {
            url: url,
            method: options.method,
            headers: options.headers,
            hasBody: !!options.body,
            bodyType: options.body instanceof FormData ? 'FormData' : typeof options.body
          };

          const startTime = performance.now();
          const response = await fetch(url, options);
          const responseTime = Math.round(performance.now() - startTime);

          let body;
          const contentType = response.headers.get('content-type');
          if (contentType?.includes('application/json')) {
            body = await response.json();
          } else {
            body = await response.text();
          }

          // Add helpful suggestions for error responses
          const enhancedBody = response.status >= 400
            ? this.enhanceErrorResponse(body, response.status)
            : body;

          this.response = {
            status: response.status,
            statusText: response.statusText,
            body: enhancedBody,
            time: responseTime,
            request: this.lastRequest
          };

          // Save to history
          this.saveToHistory();

        } catch (error) {
          this.response = {
            status: 0,
            statusText: 'Network Error',
            body: this.formatNetworkError(error),
            time: 0
          };
        } finally {
          this.isLoading = false;
        }
      },

      // Enhance error responses with actionable suggestions
      enhanceErrorResponse(body, status) {
        const suggestions = [];

        // Add suggestions based on status code
        if (status === 401) {
          suggestions.push('Add or update your API token in the authentication section');
          suggestions.push('Check if your token has expired');
          suggestions.push('Verify your token has the correct permissions');
        } else if (status === 403) {
          suggestions.push('Your token doesn\'t have permission for this action');
          suggestions.push('Contact your team admin to adjust permissions');
        } else if (status === 404) {
          suggestions.push('Check if the resource ID is correct');
          suggestions.push('Verify the endpoint path matches the API documentation');
        } else if (status === 422) {
          suggestions.push('Review the required parameters');
          suggestions.push('Check parameter format and data types');
          suggestions.push('Look for validation errors in the response');
        } else if (status === 429) {
          suggestions.push('You\'ve exceeded the rate limit - wait a moment');
          suggestions.push('Reduce request frequency');
          suggestions.push('Check your team\'s rate limit quota');
        } else if (status >= 500) {
          suggestions.push('The API server encountered an error');
          suggestions.push('Try again in a few moments');
          suggestions.push('Contact support if the issue persists');
        }

        // If body is an object, add suggestions to it
        if (typeof body === 'object' && body !== null) {
          return {
            ...body,
            _suggestions: suggestions.length > 0 ? suggestions : undefined
          };
        }

        // If body is a string or other type, wrap it
        return {
          error: body,
          _suggestions: suggestions.length > 0 ? suggestions : undefined
        };
      },

      // Format network errors with actionable suggestions
      formatNetworkError(error) {
        const suggestions = [];

        if (error.message.includes('Failed to fetch')) {
          suggestions.push('Check your internet connection');
          suggestions.push('Verify the API endpoint URL is correct');
          suggestions.push('Check if the API server is running');
          suggestions.push('Look for CORS issues in browser console');
        } else if (error.message.includes('NetworkError')) {
          suggestions.push('Check your firewall settings');
          suggestions.push('Verify the API server is accessible');
        } else if (error.message.includes('timeout')) {
          suggestions.push('The request took too long - try again');
          suggestions.push('Check if the API server is responding slowly');
        }

        return {
          error: 'Network Error',
          message: error.message,
          _suggestions: suggestions.length > 0 ? suggestions : [
            'Check your network connection',
            'Verify the API endpoint is correct',
            'Try again in a moment'
          ]
        };
      },

      buildUrl() {
        let path = this.selectedEndpoint.path;

        // Replace path parameters
        this.selectedEndpoint.parameters.forEach(param => {
          if (param.location === 'path') {
            const value = this.requestParams[param.name];
            if (value && path.includes(`{${param.name}}`)) {
              path = path.replace(`{${param.name}}`, value);
            }
          }
        });

        // Build query string from query parameters only
        const queryParams = new URLSearchParams();
        this.selectedEndpoint.parameters.forEach(param => {
          if (param.location === 'query') {
            const value = this.requestParams[param.name];
            if (value !== null && value !== undefined && value !== '') {
              queryParams.append(param.name, value);
            }
          }
        });

        const queryString = queryParams.toString();
        const url = `${this.getApiUrl()}${path}`;
        return queryString ? `${url}?${queryString}` : url;
      },

      buildRequestOptions() {
        const options = {
          method: this.selectedEndpoint.method,
          headers: {}
        };

        // Add auth header for required or optional auth endpoints
        if (this.token && (this.selectedEndpoint.requiresAuth || this.selectedEndpoint.optionalAuth)) {
          options.headers['Authorization'] = `Bearer ${this.token}`;
        }

        // Get body parameters only
        const bodyParams = this.selectedEndpoint.parameters.filter(p => p.location === 'body');

        if (bodyParams.length > 0) {
          // Check if we have file uploads
          const hasFileUpload = bodyParams.some(p => p.type === 'file' && this.requestParams[p.name]);

          if (hasFileUpload) {
            // Use FormData for file uploads
            const formData = new FormData();

            // Add all body parameters to FormData
            bodyParams.forEach(param => {
              const value = this.requestParams[param.name];
              if (value instanceof File) {
                formData.append(param.name, value);
              } else if (value !== null && value !== undefined && value !== '') {
                formData.append(param.name, value);
              }
            });

            options.body = formData;
            // Don't set Content-Type header - browser will set it with boundary
          } else {
            // Use JSON for regular body
            const body = {};
            bodyParams.forEach(param => {
              const value = this.requestParams[param.name];
              if (value !== null && value !== undefined && value !== '') {
                body[param.name] = value;
              }
            });

            if (Object.keys(body).length > 0) {
              options.headers['Content-Type'] = 'application/json';
              options.body = JSON.stringify(body);
            }
          }
        }

        return options;
      },

      // Response Handling
      getStatusClass(status) {
        if (status >= 200 && status < 300) return 'success';
        if (status >= 400 && status < 500) return 'warning';
        if (status >= 500) return 'error';
        return 'info';
      },

      formatResponseBody(body) {
        if (typeof body === 'object') {
          return JSON.stringify(body, null, 2);
        }
        return body;
      },

      // History Management
      saveToHistory() {
        const historyItem = {
          id: Date.now(),
          timestamp: new Date().toISOString(),
          method: this.selectedEndpoint.method,
          path: this.selectedEndpoint.path,
          url: this.buildUrl(),
          status: this.response.status,
          request: {
            params: this.requestParams
          },
          response: this.response
        };

        this.requestHistory.unshift(historyItem);
        if (this.requestHistory.length > 50) {
          this.requestHistory = this.requestHistory.slice(0, 50);
        }
        localStorage.setItem('request_history', JSON.stringify(this.requestHistory));
      },

      loadFromHistory(item) {
        const endpoint = this.endpoints.find(e => e.path === item.path);
        if (endpoint) {
          this.selectEndpoint(endpoint);
          this.requestParams = item.request.params || {};
          this.response = item.response;
          this.activeView = 'endpoints';
        }
      },

      clearHistory() {
        if (confirm('Clear all history?')) {
          this.requestHistory = [];
          localStorage.removeItem('request_history');
        }
      },

      formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diff = now - date;

        if (diff < 60000) return 'Just now';
        if (diff < 3600000) return `${Math.floor(diff / 60000)} minutes ago`;
        if (diff < 86400000) return `${Math.floor(diff / 3600000)} hours ago`;
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
      },

      // Copy to Clipboard
      async copyCode(code, tab) {
        try {
          await navigator.clipboard.writeText(code);
          this.copiedCode = tab;
          setTimeout(() => {
            this.copiedCode = null;
          }, 2000);
        } catch (err) {
          console.error('Failed to copy code:', err);
        }
      },

      // Code Generators
      generateCurl() {
        const url = this.buildUrl();
        const lines = [`curl -X ${this.selectedEndpoint.method} '${url}' \\`];

        // Add auth header
        if (this.token && (this.selectedEndpoint.requiresAuth || this.selectedEndpoint.optionalAuth)) {
          lines.push(`  -H 'Authorization: Bearer ${this.token}' \\`);
        }

        // Handle body parameters
        const bodyParams = this.selectedEndpoint.parameters.filter(p => p.location === 'body');
        const hasFile = bodyParams.some(p => p.type === 'file');

        if (bodyParams.length > 0) {
          if (hasFile) {
            // Use FormData with -F flags
            bodyParams.forEach((param, idx) => {
              const value = this.requestParams[param.name];
              if (value) {
                if (param.type === 'file') {
                  const isLast = idx === bodyParams.length - 1;
                  lines.push(`  -F '${param.name}=@/path/to/file.jpg'${isLast ? '' : ' \\'}`);
                } else {
                  const isLast = idx === bodyParams.length - 1;
                  lines.push(`  -F '${param.name}=${value}'${isLast ? '' : ' \\'}`);
                }
              }
            });
          } else {
            // Use JSON body
            lines.push(`  -H 'Content-Type: application/json' \\`);
            const body = {};
            bodyParams.forEach(p => {
              if (this.requestParams[p.name]) {
                body[p.name] = this.requestParams[p.name];
              }
            });
            const lastLine = `  -d '${JSON.stringify(body)}'`;
            lines.push(lastLine);
          }
        } else {
          // Remove trailing backslash from last line
          lines[lines.length - 1] = lines[lines.length - 1].replace(' \\', '');
        }

        return lines.join('\n');
      },

      generateJavaScript() {
        const url = this.buildUrl();
        const lines = [];
        const bodyParams = this.selectedEndpoint.parameters.filter(p => p.location === 'body');
        const hasFile = bodyParams.some(p => p.type === 'file');

        if (hasFile) {
          // Using FormData
          lines.push('const formData = new FormData();');
          bodyParams.forEach(p => {
            const value = this.requestParams[p.name];
            if (value) {
              if (p.type === 'file') {
                lines.push(`formData.append('${p.name}', fileInput.files[0]);`);
              } else {
                lines.push(`formData.append('${p.name}', '${value}');`);
              }
            }
          });
          lines.push('');
          lines.push(`const response = await fetch('${url}', {`);
          lines.push(`  method: '${this.selectedEndpoint.method}',`);
          if (this.token && (this.selectedEndpoint.requiresAuth || this.selectedEndpoint.optionalAuth)) {
            lines.push(`  headers: {`);
            lines.push(`    'Authorization': 'Bearer ${this.token}'`);
            lines.push(`  },`);
          }
          lines.push(`  body: formData`);
          lines.push(`});`);
        } else {
          // Using JSON
          lines.push(`const response = await fetch('${url}', {`);
          lines.push(`  method: '${this.selectedEndpoint.method}',`);
          lines.push(`  headers: {`);
          if (this.token && (this.selectedEndpoint.requiresAuth || this.selectedEndpoint.optionalAuth)) {
            lines.push(`    'Authorization': 'Bearer ${this.token}',`);
          }
          if (bodyParams.length > 0) {
            lines.push(`    'Content-Type': 'application/json'`);
          } else {
            // Remove trailing comma
            if (this.token && (this.selectedEndpoint.requiresAuth || this.selectedEndpoint.optionalAuth)) {
              lines[lines.length - 1] = lines[lines.length - 1].replace(',', '');
            }
          }
          lines.push(`  }`);

          if (bodyParams.length > 0) {
            const body = {};
            bodyParams.forEach(p => {
              if (this.requestParams[p.name]) {
                body[p.name] = this.requestParams[p.name];
              }
            });
            lines.push(`  body: JSON.stringify(${JSON.stringify(body, null, 2)})`);
          }
          lines.push(`});`);
        }

        lines.push('');
        lines.push('const data = await response.json();');
        lines.push('console.log(data);');

        return lines.join('\n');
      },

      generatePython() {
        const url = this.buildUrl();
        const lines = ['import requests'];
        lines.push('');

        const bodyParams = this.selectedEndpoint.parameters.filter(p => p.location === 'body');
        const hasFile = bodyParams.some(p => p.type === 'file');

        // Headers
        if (this.token && (this.selectedEndpoint.requiresAuth || this.selectedEndpoint.optionalAuth)) {
          lines.push(`headers = {'Authorization': 'Bearer ${this.token}'}`);
        }

        if (hasFile) {
          // Using files
          lines.push(`files = {`);
          bodyParams.forEach(p => {
            const value = this.requestParams[p.name];
            if (value) {
              if (p.type === 'file') {
                lines.push(`    '${p.name}': open('/path/to/file.jpg', 'rb')`);
              }
            }
          });
          lines.push(`}`);

          // Data for non-file fields
          const nonFileParams = bodyParams.filter(p => p.type !== 'file' && this.requestParams[p.name]);
          if (nonFileParams.length > 0) {
            lines.push(`data = {`);
            nonFileParams.forEach(p => {
              lines.push(`    '${p.name}': '${this.requestParams[p.name]}'`);
            });
            lines.push(`}`);
          }

          lines.push('');
          const method = this.selectedEndpoint.method.toLowerCase();
          const args = [`'${url}'`];
          if (nonFileParams.length > 0) {
            args.push('data=data');
          }
          args.push('files=files');
          if (this.token && (this.selectedEndpoint.requiresAuth || this.selectedEndpoint.optionalAuth)) {
            args.push('headers=headers');
          }
          lines.push(`response = requests.${method}(${args.join(', ')})`);
        } else {
          // Using JSON
          if (bodyParams.length > 0) {
            lines.push(`data = {`);
            bodyParams.forEach(p => {
              if (this.requestParams[p.name]) {
                lines.push(`    '${p.name}': '${this.requestParams[p.name]}'`);
              }
            });
            lines.push(`}`);
            lines.push('');
          }

          const method = this.selectedEndpoint.method.toLowerCase();
          const args = [`'${url}'`];
          if (bodyParams.length > 0) {
            args.push('json=data');
          }
          if (this.token && (this.selectedEndpoint.requiresAuth || this.selectedEndpoint.optionalAuth)) {
            args.push('headers=headers');
          }
          lines.push(`response = requests.${method}(${args.join(', ')})`);
        }

        lines.push('print(response.json())');

        return lines.join('\n');
      },

      generatePHP() {
        const url = this.buildUrl();
        const lines = ['<?php'];
        lines.push('');

        const bodyParams = this.selectedEndpoint.parameters.filter(p => p.location === 'body');
        const hasFile = bodyParams.some(p => p.type === 'file');

        if (hasFile) {
          // Using CURLFile for file uploads
          lines.push(`$ch = curl_init('${url}');`);
          lines.push('');
          lines.push('$data = [');
          bodyParams.forEach(p => {
            const value = this.requestParams[p.name];
            if (value) {
              if (p.type === 'file') {
                lines.push(`    '${p.name}' => new CURLFile('/path/to/file.jpg'),`);
              } else {
                lines.push(`    '${p.name}' => '${value}',`);
              }
            }
          });
          lines.push('];');
          lines.push('');
          lines.push('curl_setopt_array($ch, [');
          lines.push(`    CURLOPT_CUSTOMREQUEST => '${this.selectedEndpoint.method}',`);
          lines.push('    CURLOPT_POSTFIELDS => $data,');
          lines.push('    CURLOPT_RETURNTRANSFER => true,');
          if (this.token && (this.selectedEndpoint.requiresAuth || this.selectedEndpoint.optionalAuth)) {
            lines.push('    CURLOPT_HTTPHEADER => [');
            lines.push(`        'Authorization: Bearer ${this.token}'`);
            lines.push('    ]');
          }
          lines.push(']);');
        } else {
          // Using JSON
          if (bodyParams.length > 0) {
            lines.push('$data = [');
            bodyParams.forEach(p => {
              if (this.requestParams[p.name]) {
                lines.push(`    '${p.name}' => '${this.requestParams[p.name]}',`);
              }
            });
            lines.push('];');
            lines.push('');
          }

          lines.push(`$ch = curl_init('${url}');`);
          lines.push('curl_setopt_array($ch, [');
          lines.push(`    CURLOPT_CUSTOMREQUEST => '${this.selectedEndpoint.method}',`);
          if (bodyParams.length > 0) {
            lines.push('    CURLOPT_POSTFIELDS => json_encode($data),');
          }
          lines.push('    CURLOPT_RETURNTRANSFER => true,');
          lines.push('    CURLOPT_HTTPHEADER => [');
          if (this.token && (this.selectedEndpoint.requiresAuth || this.selectedEndpoint.optionalAuth)) {
            lines.push(`        'Authorization: Bearer ${this.token}',`);
          }
          if (bodyParams.length > 0) {
            lines.push(`        'Content-Type: application/json'`);
          } else {
            // Remove trailing comma
            if (this.token && (this.selectedEndpoint.requiresAuth || this.selectedEndpoint.optionalAuth)) {
              lines[lines.length - 1] = lines[lines.length - 1].replace(',', '');
            }
          }
          lines.push('    ]');
          lines.push(']);');
        }

        lines.push('');
        lines.push('$response = curl_exec($ch);');
        lines.push('$data = json_decode($response);');
        lines.push('print_r($data);');
        lines.push('');
        lines.push('curl_close($ch);');

        return lines.join('\n');
      }
    }));

    // Documentation Viewer Component
    Alpine.data('documentationViewer', () => ({
      loading: true,
      error: null,
      renderedDocs: '',

      async init() {
        await this.loadDocumentation();
      },

      async loadDocumentation() {
        try {
          this.loading = true;
          this.error = null;

          // Fetch markdown documentation
          const response = await fetch('/api-documentation.md');
          if (!response.ok) {
            throw new Error('Failed to load documentation');
          }

          const markdown = await response.text();

          // Import marked dynamically
          const { marked } = await import('marked');

          // Configure marked for security and features
          marked.setOptions({
            headerIds: true,
            mangle: false,
            breaks: true
          });

          // Render markdown to HTML
          this.renderedDocs = marked.parse(markdown);

          // Highlight code blocks after render
          this.$nextTick(() => {
            document.querySelectorAll('.documentation-content pre code').forEach((block) => {
              if (window.Prism) {
                window.Prism.highlightElement(block);
              }
            });
          });

        } catch (error) {
          console.error('Failed to load documentation:', error);
          this.error = 'Failed to load documentation. Please try again.';
        } finally {
          this.loading = false;
        }
      }
    }));
  });
</script>

<style>
  [x-cloak] { display: none !important; }
</style>